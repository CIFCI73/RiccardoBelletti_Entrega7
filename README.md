# RiccardoBelletti_Entrega7
Me llamo Riccardo Belletti. Este proyecto es mi práctica para la asignatura: una pequeña simulación del Sistema Solar escrita en JavaScript usando Three.js. En la versión que entrego hay ocho planetas (Mercurio, Venus, Tierra con su capa de nubes, Marte, Júpiter, Saturno con anillos, Urano y Neptuno), una luna que orbita la Tierra y una estrella central que hace de Sol. He incluido texturas para todos los planetas, bump y specular maps donde convenía, sombras y dos modos de cámara: una vista orbital para observar el conjunto y una vista tipo “nave” para volar entre los cuerpos.

Para la interacción en la escena utilizo dos controles distintos: OrbitControls para la vista orbital y FlyControls para la vista tipo nave.
OrbitControls está activo por defecto, permitiendo al usuario explorar la escena de manera global con el ratón: es posible orbitar alrededor del sistema solar arrastrando el botón izquierdo, hacer zoom con la rueda del ratón y desplazar la cámara lateralmente (pan) arrastrando el botón derecho.
Para la vista en primera persona, FlyControls ofrece un control de vuelo libre a través del teclado. El usuario puede moverse adelante y atrás con W y S, desplazarse lateralmente con A y D, cambiar la orientación de la vista con las flechas de dirección, y rotar sobre el propio eje con Q y E.
El cambio entre ambos modos se realiza pulsando la barra espaciadora: en el manejador del evento keydown, compruebo si la tecla pulsada es el espacio (keyCode === 32) y alterno las propiedades .enabled de cada control. Al cambiar al modo nave, la cámara se posiciona cerca de la Tierra (usando camera.position.copy(laTierra.position).add(offset)) y se enfoca en ella con camera.lookAt(). Al volver al modo órbita, se restaura la posición inicial de la cámara y se reinicia el target de OrbitControls para centrar de nuevo la escena.

La luz la manejo con una luz ambiental (AmbientLight) que aporta iluminación base y una luz direccional (DirectionalLight) que representa la emisión solar. He decidido no añadir la DirectionalLight directamente a la escena como objeto separado de la estrella, sino añadirla como hijo de la malla del Sol (estrella.add(Ldir)), para que conceptualmente la luz venga del Sol. Configuro Ldir.castShadow = true y ajusto su cámara de sombras (shadow.camera.left/right/top/bottom, near/far y mapSize) para que las sombras proyectadas por los planetas sean aprovechables en escena grande. Esto requiere ajustar valores grandes (shadowArea = 500) para abarcar el sistema.

La estructura de creación de objetos se apoya en tres funciones principales: Estrella(), Esfera() y Luna(). Estrella(rad, col, texture) crea una esfera grande con SphereGeometry y un MeshBasicMaterial. Uso MeshBasicMaterial porque el Sol debe “emitir” luz y no necesita recibir iluminación de la escena para verse bien; además, si le pongo material.map = texture aplico la textura solar. Estrella añade también la luz direccional para que su posición sea coherente con la malla del Sol.

Esfera(padre, dist, vel, f1, f2, radio, nx, ny, col, texture, texbump, texspec, texalpha, sombra) es la función que uso para crear planetas. Recibe como padre el objeto al que se añade (normalmente scene), dist es la distancia orbital base, vel la velocidad angular (puede ser negativa para invertir sentido), f1 y f2 escalas para convertir la órbita en elipse (a menudo 1.0 y 1.0), radio es el tamaño visual, nx/ny los segmentos de la esfera y varios mapas opcionales. Dentro creo SphereBufferGeometry con los segmentos pedidos y un MeshPhongMaterial, que me permite usar map, bumpMap y specularMap. Si se pasa texalpha, lo asigno a material.alphaMap y activo material.transparent = true y material.side = DoubleSide para poder ver la capa con transparencia (esto era útil para la capa de nubes de la Tierra). Tras crear la malla (mesh = new THREE.Mesh(geometry, material)) ajusto mesh.rotation.x = Math.PI + Math.PI / 2 en mi versión final porque hice pruebas con la orientación de las texturas y encontré que esta rotación alinea correctamente los polos para las texturas que usé (varias texturas estaban orientadas diferente y esto fue la forma práctica que me funcionó en mi entorno). Luego asigno mesh.userData con dist, speed, f1, f2 para que el bucle de animación pueda leer esos parámetros y actualizar la posición orbital. Si padre == scene entonces dibujo la órbita con EllipseCurve, genero los puntos y creo una Line que añado al padre para que se vea la trayectoria. Finalmente padre.add(mesh) y hago objetos.push(mesh) para incluirlo en el array que actualizo en cada frame. La idea de parametrizar todo así me permitió cambiar fácilmente valores (radius, velocidad, elipticidad) sin tocar el bucle.

Luna(planeta, radio, dist, vel, col, angle, f1, f2, texture, sombra) la implementé aparte porque la luna tiene un comportamiento diferente: no quiero que la luna orbite alrededor del origen, sino alrededor de la Tierra. Para eso creo un pivot con new THREE.Object3D() y lo roto en X por el angle recibido; añado el pivot como hijo del planeta (planeta.add(pivote)), creo la malla de la luna y la añado al pivote. De este modo la posición que calculo para la luna (usando cos/sin y su userData.dist) es relativa al pivot y, puesto que el pivot está sujeto a la Tierra, la luna describe la órbita correctamente alrededor del planeta aun cuando la Tierra se mueva alrededor del Sol. También para la luna dibujo su órbita con EllipseCurve, pero la añado al pivote para que la representación visual respete la relación espacial. Guardé las lunas en Lunas.push(luna) y actualizo sus posiciones en el animationLoop.

Para Saturno añadí createRings(planeta), donde uso RingGeometry y una textura con canal alpha. Construyo un MeshBasicMaterial con la textura de anillos y transparent: true, y roté los anillos (rotation.x = Math.PI / 2 y rotation.z ligeramente) para darle la inclinación que quería. Los anillos están añadidos como hijos de la malla de Saturno para que sigan su movimiento.

El bucle de animación es la pieza central: en animationLoop() calculo timestamp = (Date.now() - t0) * accglobal (uso accglobal como factor global de tiempo para poder escalar la velocidad general del sistema). Llamo requestAnimationFrame(animationLoop) para que el navegador ejecute la función en el siguiente frame. Luego recorro objetos y para cada uno actualizo position.x = cos(timestamp * speed) * f1 * dist y position.y = sin(timestamp * speed) * f2 * dist; con esto implemento la parametrización clásica de una elipse x = a cos(t), y = b sin(t). Además en cada paso hago object.rotation.y -= 0.008 para que cada planeta gire sobre su propio eje. Para las lunas uso la misma fórmula pero sin f1/f2 en mi caso concreto, y sus posiciones se calculan en el espacio del pivot correspondiente. Para los FlyControls uso un Clock (const clock = new THREE.Clock()) y en cada frame hago const delta = clock.getDelta(); flyControls.update(delta); porque FlyControls.update() necesita el tiempo delta para funcionar correctamente y moverse de manera uniforme.

Sobre texturas y mapas, descargué los assets de Solar System Scope (https://www.solarsystemscope.com/textures/.) y los cargué con new THREE.TextureLoader().load(...). Para la Tierra usé earthmap1k.jpg como map, earthbump1k.jpg como bumpMap y earthspec1k.jpg como specularMap. Para las nubes usé una clouds map y un alphaMap para controlar la transparencia. En la práctica tuve que experimentar con texture.center y texture.rotation y con rotaciones en la propia malla para conseguir que polos y ejes quedaran alineados, porque las texturas que se encuentran en la web no siempre tienen la misma convención. Finalmente ajusté material.transparent, material.blending y material.depthWrite = false en la capa de nubes cuando hacía falta para que no taparan la superficie terrestre.


En resumen, el proyecto reúne la creación de los objetos principales con funciones reutilizables (Estrella, Esfera, Luna), gestión de texturas y materiales complejos, dos modos de cámara intercambiables, animación por tiempo y manejo de sombras. La intención era juntar elementos de prácticas previas que ya había usado, unirlos y pulir detalles prácticos (alineación de texturas, anillos, pivot para lunas, control fino de FlyControls) para obtener una demo interactiva que permita tanto ver el sistema desde fuera como “entrar” con la nave y explorar la Tierra y sus vecinos. Si hace falta, puedo adaptar este texto para ponerlo directamente en el README del repositorio en español o traducirlo al italiano con el mismo tono.
